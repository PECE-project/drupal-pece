<?php
/**
 * @file
 * Contains \Drupal\pece_migrate\Plugin\migrate\source\Node
 */
namespace  Drupal\pece_migrate\Plugin\migrate\source;
use Drupal\migrate\Row;
use Drupal\node\Plugin\migrate\source\d7\NodeComplete as D7Node;
use Drupal\Tests\Component\Annotation\Doctrine\Ticket\Doctrine\ORM\Entity;
use Exception;

/**
 * Gets all node revisions from the source, including translation revisions.
 *
 * @MigrateSource(
 *   id = "v1_node",
 *   source_module = "node"
 * )
 */
class Node extends D7Node {

  const PERMISSION_RESTRICTED = 'restricted';
  const PERMISSION_PRIVATE = 'private';
  const PERMISSION_OPEN = 'open';
  const GROUP_PUBLIC = 0;
  const GROUP_PRIVATE = 1;
  const CONTENT_VISIBILITY_DEFAULT = 0;
  const CONTENT_VISIBILITY_PUBLIC = 1;
  const CONTENT_VISIBILITY_PRIVATE = 1;
  const CONCEPTUALIZE = 'conceptualize';
  const CURATE = 'curate';
  const ARCHIVE = 'archive';
  const ANALYZE = 'analyze';

  protected $permissionByUserView = [];

  public function query() {
    $query =  parent::query(); // TODO: Change the autogenerated stub

    return $query;
  }

  /**
   * {@inheritdoc}
   */
  public function fields() {
    $fields = parent::fields() + ['alias' => $this->t('Path alias')];
    $fields += ['permission_all_user_view' => $this->t('Permission for all users')];
    $fields += ['groups_with_view_access' => $this->t('Groups with view access')];
    $fields += ['people_with_edit_access' => $this->t('People with edit access')];
    $fields += ['pece_researchers_group' => $this->t('Pece v1 Researchers')];
    $fields += ['static_legacy_content' => $this->t('Static legacy content')];
    $fields += ['unpublish_content' => $this->t('Unpublish content')];
    $fields += ['curate' => $this->t('Curate')];
    $fields += ['conceptualize' => $this->t('Conceptualize')];
    $fields += ['analyze' => $this->t('Analyze')];
    $fields += ['archive' => $this->t('Archive')];
    return $fields;
  }

  /**
   * {@inheritdoc}
   * @throws Exception
   */
  public function prepareRow(Row $row) {
    // Include path alias.
    $nid = $row->getSourceProperty('nid');
    $query = $this->select('url_alias', 'ua')
      ->fields('ua', ['alias']);
    $query->condition('ua.source', 'node/' . $nid);
    $alias = $query->execute()->fetchField();
    if (!empty($alias)) {
      $row->setSourceProperty('alias', '/' . $alias);
    }

    // Check permissions
    $query = $this->select('field_data_field_permissions', 'fdfp')
      ->fields('fdfp', ['field_permissions_value'])
      ->condition('fdfp.entity_id', $nid);
    $permission = $query->execute()->fetchField();

    $groups = $this->getGroupsByContent($nid);
    $group_terms = [];
    foreach ($groups as $key => $item) {
      $group_terms[] = [
        'target_id' => $item
      ];
    }
    $row->setSourceProperty('groups_with_view_access', $group_terms);

    if ($permission == self::PERMISSION_OPEN) {
      // Check if content belongs to any group
      if (count($groups) > 0) {
        // Check group access (public = 0, private = 1)
        $groupAccess = $this->checkGroupsAccess($groups);
        // Get group content visibility
        $groupContentVisibility = $this->checkGroupsContentVisibility($groups);

        if ($groupAccess == self::GROUP_PUBLIC && $groupContentVisibility !== self::CONTENT_VISIBILITY_PRIVATE) {
          // All users can see the content
          $row->setSourceProperty('permission_all_user_view', true);
        }

        if ($groupAccess == self::GROUP_PRIVATE && $groupContentVisibility == self::CONTENT_VISIBILITY_PUBLIC) {
          $row->setSourceProperty('permission_all_user_view', true);
        }
      } else {
        // All users see the content
        $row->setSourceProperty('permission_all_user_view', true);
      }
    }

    $set_researchers_group = [];
    if ($permission == self::PERMISSION_RESTRICTED) {
      // If permission restricted, prepare the PECE v1 Restricted Content group
      // All legacy users are members of this group (see v1_user migration)
      $legacy_researchers_group_array = \Drupal::entityTypeManager()->getStorage('taxonomy_term')
        ->loadByProperties(['name' => 'PECE v1 Researchers', 'vid' => 'groups']);
      $legacy_researchers_group_id = $legacy_researchers_group_array ? reset($legacy_researchers_group_array)->id() : NULL;
      $researchers_group = [
        [
          'target_id' => $legacy_researchers_group_id
        ]
      ];
      // Check if content belongs to any group
      if (count($groups) > 0) {

        $groupAccess = $this->checkGroupsAccess($groups);
        // Get group content visibility
        $groupContentVisibility = $this->checkGroupsContentVisibility($groups);

        if (($groupAccess == self::GROUP_PUBLIC && $groupContentVisibility !== self::CONTENT_VISIBILITY_PRIVATE) || ($groupAccess == self::GROUP_PRIVATE && $groupContentVisibility == self::CONTENT_VISIBILITY_PUBLIC)) {
          // All researchers can see the content
          $set_researchers_group = $researchers_group;
        } else {
          $row->setSourceProperty('unpublish_content', 0);
        }

      } else {
        $set_researchers_group = $researchers_group;
      }
    }

    if ($permission == self::PERMISSION_PRIVATE) {
      $row->setSourceProperty('unpublish_content', 0);
    }

    $row->setSourceProperty('pece_researchers_group', $set_researchers_group);

    $collaborators = $this->select('field_data_field_pece_contributors', 'collab')
      ->fields('collab', ['field_pece_contributors_target_id'])
      ->condition('collab.entity_id', $nid)
      ->execute()->fetchCol();
    // $people_with_edit_access = $row->getSourceProperty('field_pece_contributors') ?? [];
    $author = $row->getSourceProperty('node_uid');
    array_push($collaborators, $author);
    $people_with_edit_access = array_unique($collaborators);

    $row->setSourceProperty('people_with_edit_access', $people_with_edit_access);

    $content_type = $row->getSourceProperty('type');
    if ($content_type === 'pece_essay') {
      // Get the static legacy content of the essay
      $html = $this->select('essay_content', 'ec')
        ->fields('ec', ['content'])
        ->condition('ec.nodeid', $nid)
        ->execute()->fetchField();

      $row->setSourceProperty('static_legacy_content', $html);

      // Get the Display ID for the node in its current revision.
      $did = $this->select('panelizer_entity', 'pe')
        ->fields('pe', ['did'])
        ->condition('pe.revision_id', $row->getSourceProperty('vid'));

      // Note that panes_map is a custom table, that must be created before the migration.
      // Collect the fpid of all fieldable panel panes of the node bundle.
      $node_fpid = $this->select('panes_map', 'pm')
        ->fields('pm', ['entity_id'])
        ->condition('pm.did', $did, 'IN')
        ->condition('pm.bundle', 'node');

      $referenced_nids = $this->select('field_data_field_node', 'fn')
        ->fields('fn', ['field_node_target_id'])
        ->condition('fn.entity_id', $node_fpid, 'IN')
        ->distinct();

      $referenced_nodes = $this->select('node', 'n')
        ->fields('n', ['nid', 'type'])
        ->condition('n.nid', $referenced_nids, 'IN')
        ->execute()->fetchAllKeyed();


      $node_category_map = [
        'pece_fieldsite' => self::CONCEPTUALIZE,
        'pece_project' => self::CONCEPTUALIZE,
        'pece_sub_logic' => self::CONCEPTUALIZE,
        // 'design logic' => self::CONCEPTUALIZE,
        'pece_artifact_tabular' => self::ARCHIVE,
        'pece_artifact_video' => self::ARCHIVE,
        'pece_artifact_audio' => self::ARCHIVE,
        'pece_artifact_fieldnote' => self::ARCHIVE,
        'pece_artifact_image' => self::ARCHIVE,
        'pece_artifact_pdf' => self::ARCHIVE,
        'pece_artifact_text' => self::ARCHIVE,
        'pece_artifact_website' => self::ARCHIVE,
        'pece_artifact_bundle' => self::ARCHIVE,
        'pece_analytic' => self::ANALYZE,
        'pece_annotation' => self::ANALYZE,
        'pece_memo' => self::ANALYZE,
        'pece_essay' => self::CURATE,
        'pece_timeline_essay' => self::CURATE,
        'pece_photo_essay' => self::CURATE,
      ];

      $curate = [];
      $conceptualize = [];
      $analyze = [];
      $archive = [];
      foreach ($referenced_nodes as $nid => $bundle) {
        if ($node_category_map[$bundle] === self::CONCEPTUALIZE) {
          $conceptualize[] = [
            'target_id' => $nid
          ];
        }
        if ($node_category_map[$bundle] === self::CURATE) {
          $curate[] = [
            'target_id' => $nid
          ];
        }
        if ($node_category_map[$bundle] === self::ANALYZE) {
          $analyze[] = [
            'target_id' => $nid
          ];
        }
        if ($node_category_map[$bundle] === self::ARCHIVE) {
          $archive[] = [
            'target_id' => $nid
          ];
        }
      }

      $row->setSourceProperty(self::CONCEPTUALIZE, $conceptualize);
      $row->setSourceProperty(self::CURATE, $curate);
      $row->setSourceProperty(self::ANALYZE, $analyze);
      $row->setSourceProperty(self::ARCHIVE, $archive);
    }

    return parent::prepareRow($row);
  }

  /**
   * Check groups access.
   * @throws Exception
   */
  public function checkGroupsAccess($groups): int
  {
    $access = 0;
    foreach ($groups as $key => $item) {
      $query = $this->select('field_data_group_access', 'fdga')
        ->fields('fdga', ['group_access_value'])
        ->condition('fdga.entity_id', $item);
      $access = $query->execute()->fetchField();
      //"What was once Public cannot be hidden by mistake" by Reva
      if ($access == 0)
        break;
    }
    return $access;
  }

  /**
   * Check groups visibility.
   * @throws Exception
   */
  public function checkGroupsContentVisibility($groups): int
  {
    $visibility = 0;
    foreach ($groups as $key => $item) {
      $query = $this->select('field_data_group_content_access', 'fdgca')
        ->fields('fdgca', ['group_content_access_value'])
        ->condition('fdgca.entity_id', $item);
      //default == 0, public == 1, private == 2
      $visibility = $query->execute()->fetchField();
      //"What was once Public cannot be hidden by mistake" by Reva
      if ($visibility == 1)
        break;
    }
    return $visibility;
  }

  /**
   * TODO: Check 'Group content visibility' field functionality in content (not in group) with Reva
   * Check the 'Group content visibility' field by content id
   * @throws Exception
   */
  public function checkGroupContentVisibility($nid): int
  {
    $query = $this->select('field_data_group_content_access', 'fdgca')
      ->fields('fdgca', ['group_content_access_value'])
      ->condition('fdgca.entity_id', $nid);
    //default == 0, public == 1, private == 2
    return $query->execute()->fetchField();
  }

  /**
   * Get the content groups
   * @throws Exception
   */
  public function getGroupsByContent($nid)
  {
    $query = $this->select('og_membership', 'ogm')
      ->fields('ogm', ['gid'])
      ->condition('ogm.etid', $nid)
      ->condition('field_name', 'og_group_ref');
    return $query->execute()->fetchCol();
  }
}
